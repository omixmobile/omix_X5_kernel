/*Gionee <GN_BSP_SYS> <chuqf> <20161028> add for GnEfuseBlowerState begin*/

#include <linux/fs.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/io.h>
#include <asm/uaccess.h>
#include <linux/file.h>
#include <linux/delay.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/kthread.h>
#include <linux/semaphore.h>

//#define EFUSE_PATH       "/dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/efuse"
#define EFUSE_PATH "/dev/block/platform/bootdevice/by-name/efuse"


int GnEfuseBlowerState = 0;
struct task_struct *blower_th;
struct semaphore efuse_blower_thread_sem;
//mtk6755 secure boot v2.0 efuse
//Antai <ANT_BSP_EFUSE> <chendonghai/lihl> <20180227> add for MT6771 efuse key begin
#ifdef CONFIG_AI_BSP_MT6765_PLATFORM
//for mt6765
static char efuse_data[] = {
0xF6,0xE2,0xB1,0x90,0xC9,0xA8,0xD5,0x73,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6C,0xA4,
0x53,0xA7,0x27,0xF1,0xC7,0xE2,0x0E,0x0D,0x74,0xB4,
0xF9,0x48,0xBE,0xB9,0xF8,0x9F,0x78,0x63,0xF4,0x79,
0x02,0x4F,0x4E,0xF3,0xEB,0x05,0x60,0x68,0x6D,0xBC,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x75,0x47,0x66,0x4D,0x56,0xBB,0xC3,0xC5,0x1B,0xE1,
0x93,0xD7,0xA8,0x3E,0xB9,0x97,0xCA,0x27,0x00,0xC0,
0x61,0x19,0x26,0x2B,0x99,0x76,0xD0,0x53,0x12,0xF9,
0xE7,0x82
};
#else
//Antai <ANT_BSP_EFUSE> <chendonghai/lihl> <20180227> add for MT6771 efuse key end
//for mt6739
static char efuse_data[] = {
   0xF6, 0xE2, 0xB1, 0x90, 0xC9, 0xA8, 0xD5, 0x73,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC7, 0xAE, 0xAF, 0x9E,
    0xC6, 0x29, 0xCB, 0xE9, 0xE6, 0x12, 0x5B, 0x3E,
    0x3B, 0xA9, 0xFA, 0xEC, 0xC7, 0x31, 0x59, 0x9B,
    0x6E, 0x7B, 0x78, 0x61, 0x48, 0x90, 0xBE, 0x67,
    0xAC, 0x7D, 0x4A, 0x8A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x12, 0x89, 0x60, 0x39, 0x53, 0x3A, 0x63, 0x66,
    0xCE, 0xB1, 0xDF, 0x4C, 0x34, 0xCA, 0x38, 0x75,
    0xA2, 0x96, 0xB1, 0xA0, 0xA4, 0xFC, 0x1E, 0xEC,
    0xB4, 0xA9, 0x88, 0x9D, 0x8F, 0x5D, 0xB4, 0x2D
};
#endif
static int update_efuse(void){
    int result = 0;
    int ret = 0;
    struct file *write_fp;
	loff_t pos = 0;
    mm_segment_t old_fs;
    
    write_fp = filp_open(EFUSE_PATH, O_RDWR, 0); //O_RDWR, O_RDONLY
    if (IS_ERR(write_fp)) {
        result = PTR_ERR(write_fp);
        printk(KERN_ERR "File open return fail,result=%d,file=%p\n", result, write_fp);
        return -ENOENT;
    }

    ret = kernel_write(write_fp, (char *)efuse_data, 512, &pos);
    if (ret < 0)
        printk(KERN_ERR "Kernel write efuse fail\n");

    old_fs = get_fs();
    set_fs(get_ds());
    ret = vfs_fsync(write_fp, 0);
    if (ret < 0)
        printk(KERN_ERR "Kernel write efuse sync fail\n");
    set_fs(old_fs);
    filp_close(write_fp, 0);

    GnEfuseBlowerState = 1;
    return ret;
}

static int efuse_blower_proc_show(struct seq_file *m, void *v){
    if (GnEfuseBlowerState){
        seq_printf(m, "%s\n", "1");
    }else{
        seq_printf(m, "%s\n", "0");
        up(&efuse_blower_thread_sem);
    }

    return 0;
}

static int efuse_blower_proc_open(struct inode *inode, struct file *file){
    return single_open(file, efuse_blower_proc_show, NULL);
}

static int efuse_blower_thread(void *context)
{
    int ret = 0;

    for (;;) {
        printk(KERN_ERR "%s: cqf start0 to write efuse partition\n", __func__);
        down(&efuse_blower_thread_sem);
        printk(KERN_ERR "%s: cqf start to write efuse partition\n", __func__);
        ret = update_efuse();
        if (!ret)
            break;
    }

    return ret;
}

static const struct file_operations efuse_blower_proc_fops = {
    .open       = efuse_blower_proc_open,
    .read       = seq_read,
    .llseek     = seq_lseek,
    .release    = single_release,
};

static int __init proc_efuse_blower_init(void){
    proc_create("efuse_blower", 0444, NULL, &efuse_blower_proc_fops);
    sema_init(&efuse_blower_thread_sem, 0);
    blower_th = kthread_run(efuse_blower_thread, NULL, "efuse_blower");
    if (IS_ERR(blower_th))
        printk(KERN_ERR "%s, init kthread_run failed!\n", __func__);
    return 0;
}
fs_initcall(proc_efuse_blower_init);
